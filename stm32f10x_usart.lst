
D:\Dropbox\Work\MWIR\Firmware\[5]MWIR - DRV8825_2 - Acctest\stm32f10x_usart.o:     file format elf32-littlearm
D:\Dropbox\Work\MWIR\Firmware\[5]MWIR - DRV8825_2 - Acctest\stm32f10x_usart.o

Disassembly of section .text.USART_DeInit:

00000000 <USART_DeInit>:
USART_DeInit():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:131
  *   This parameter can be one of the following values: 
  *      USART1, USART2, USART3, UART4 or UART5.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
   0:	b580      	push	{r7, lr}
   2:	b082      	sub	sp, #8
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:135
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
   8:	687a      	ldr	r2, [r7, #4]
   a:	f643 0300 	movw	r3, #14336	; 0x3800
   e:	f2c4 0301 	movt	r3, #16385	; 0x4001
  12:	429a      	cmp	r2, r3
  14:	d10c      	bne.n	30 <USART_DeInit+0x30>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:137
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
  16:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  1a:	f04f 0101 	mov.w	r1, #1	; 0x1
  1e:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:138
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  22:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  26:	f04f 0100 	mov.w	r1, #0	; 0x0
  2a:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
  2e:	e04e      	b.n	ce <USART_DeInit+0xce>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:140
  }
  else if (USARTx == USART2)
  30:	687a      	ldr	r2, [r7, #4]
  32:	f244 4300 	movw	r3, #17408	; 0x4400
  36:	f2c4 0300 	movt	r3, #16384	; 0x4000
  3a:	429a      	cmp	r2, r3
  3c:	d10c      	bne.n	58 <USART_DeInit+0x58>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:142
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
  3e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  42:	f04f 0101 	mov.w	r1, #1	; 0x1
  46:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:143
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  4a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  4e:	f04f 0100 	mov.w	r1, #0	; 0x0
  52:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
  56:	e03a      	b.n	ce <USART_DeInit+0xce>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:145
  }
  else if (USARTx == USART3)
  58:	687a      	ldr	r2, [r7, #4]
  5a:	f644 0300 	movw	r3, #18432	; 0x4800
  5e:	f2c4 0300 	movt	r3, #16384	; 0x4000
  62:	429a      	cmp	r2, r3
  64:	d10c      	bne.n	80 <USART_DeInit+0x80>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:147
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
  66:	f44f 2080 	mov.w	r0, #262144	; 0x40000
  6a:	f04f 0101 	mov.w	r1, #1	; 0x1
  6e:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:148
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  72:	f44f 2080 	mov.w	r0, #262144	; 0x40000
  76:	f04f 0100 	mov.w	r1, #0	; 0x0
  7a:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
  7e:	e026      	b.n	ce <USART_DeInit+0xce>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:150
  }    
  else if (USARTx == UART4)
  80:	687a      	ldr	r2, [r7, #4]
  82:	f644 4300 	movw	r3, #19456	; 0x4c00
  86:	f2c4 0300 	movt	r3, #16384	; 0x4000
  8a:	429a      	cmp	r2, r3
  8c:	d10c      	bne.n	a8 <USART_DeInit+0xa8>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:152
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
  8e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  92:	f04f 0101 	mov.w	r1, #1	; 0x1
  96:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:153
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
  9a:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  9e:	f04f 0100 	mov.w	r1, #0	; 0x0
  a2:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
  a6:	e012      	b.n	ce <USART_DeInit+0xce>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:157
  }    
  else
  {
    if (USARTx == UART5)
  a8:	687a      	ldr	r2, [r7, #4]
  aa:	f245 0300 	movw	r3, #20480	; 0x5000
  ae:	f2c4 0300 	movt	r3, #16384	; 0x4000
  b2:	429a      	cmp	r2, r3
  b4:	d10b      	bne.n	ce <USART_DeInit+0xce>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:159
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
  b6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  ba:	f04f 0101 	mov.w	r1, #1	; 0x1
  be:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:160
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
  c2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  c6:	f04f 0100 	mov.w	r1, #0	; 0x0
  ca:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:163
    }
  }
}
  ce:	f107 0708 	add.w	r7, r7, #8	; 0x8
  d2:	46bd      	mov	sp, r7
  d4:	bd80      	pop	{r7, pc}
  d6:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_Init:

00000000 <USART_Init>:
USART_Init():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:177
  *         that contains the configuration information for the specified USART 
  *         peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
   0:	b580      	push	{r7, lr}
   2:	b08c      	sub	sp, #48
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:178
  uint32_t tmpreg = 0x00, apbclock = 0x00;
   a:	f04f 0300 	mov.w	r3, #0	; 0x0
   e:	61fb      	str	r3, [r7, #28]
  10:	f04f 0300 	mov.w	r3, #0	; 0x0
  14:	623b      	str	r3, [r7, #32]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:179
  uint32_t integerdivider = 0x00;
  16:	f04f 0300 	mov.w	r3, #0	; 0x0
  1a:	627b      	str	r3, [r7, #36]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:180
  uint32_t fractionaldivider = 0x00;
  1c:	f04f 0300 	mov.w	r3, #0	; 0x0
  20:	62bb      	str	r3, [r7, #40]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:181
  uint32_t usartxbase = 0;
  22:	f04f 0300 	mov.w	r3, #0	; 0x0
  26:	62fb      	str	r3, [r7, #44]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:197
  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }

  usartxbase = (uint32_t)USARTx;
  28:	687b      	ldr	r3, [r7, #4]
  2a:	62fb      	str	r3, [r7, #44]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:200

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  2c:	687b      	ldr	r3, [r7, #4]
  2e:	8a1b      	ldrh	r3, [r3, #16]
  30:	b29b      	uxth	r3, r3
  32:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:202
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
  34:	69fa      	ldr	r2, [r7, #28]
  36:	f64c 73ff 	movw	r3, #53247	; 0xcfff
  3a:	f2c0 0300 	movt	r3, #0	; 0x0
  3e:	ea02 0303 	and.w	r3, r2, r3
  42:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:205
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  44:	683b      	ldr	r3, [r7, #0]
  46:	88db      	ldrh	r3, [r3, #6]
  48:	461a      	mov	r2, r3
  4a:	69fb      	ldr	r3, [r7, #28]
  4c:	ea43 0302 	orr.w	r3, r3, r2
  50:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:208
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
  52:	69fb      	ldr	r3, [r7, #28]
  54:	b29b      	uxth	r3, r3
  56:	687a      	ldr	r2, [r7, #4]
  58:	8213      	strh	r3, [r2, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:211

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  5a:	687b      	ldr	r3, [r7, #4]
  5c:	899b      	ldrh	r3, [r3, #12]
  5e:	b29b      	uxth	r3, r3
  60:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:213
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
  62:	69fa      	ldr	r2, [r7, #28]
  64:	f64e 13f3 	movw	r3, #59891	; 0xe9f3
  68:	f2c0 0300 	movt	r3, #0	; 0x0
  6c:	ea02 0303 	and.w	r3, r2, r3
  70:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:218
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
  72:	683b      	ldr	r3, [r7, #0]
  74:	889a      	ldrh	r2, [r3, #4]
  76:	683b      	ldr	r3, [r7, #0]
  78:	891b      	ldrh	r3, [r3, #8]
  7a:	ea42 0303 	orr.w	r3, r2, r3
  7e:	b29a      	uxth	r2, r3
  80:	683b      	ldr	r3, [r7, #0]
  82:	895b      	ldrh	r3, [r3, #10]
  84:	ea42 0303 	orr.w	r3, r2, r3
  88:	b29b      	uxth	r3, r3
  8a:	461a      	mov	r2, r3
  8c:	69fb      	ldr	r3, [r7, #28]
  8e:	ea43 0302 	orr.w	r3, r3, r2
  92:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:221
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
  94:	69fb      	ldr	r3, [r7, #28]
  96:	b29b      	uxth	r3, r3
  98:	687a      	ldr	r2, [r7, #4]
  9a:	8193      	strh	r3, [r2, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:224

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
  9c:	687b      	ldr	r3, [r7, #4]
  9e:	8a9b      	ldrh	r3, [r3, #20]
  a0:	b29b      	uxth	r3, r3
  a2:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:226
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
  a4:	69fa      	ldr	r2, [r7, #28]
  a6:	f64f 43ff 	movw	r3, #64767	; 0xfcff
  aa:	f2c0 0300 	movt	r3, #0	; 0x0
  ae:	ea02 0303 	and.w	r3, r2, r3
  b2:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:229
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  b4:	683b      	ldr	r3, [r7, #0]
  b6:	899b      	ldrh	r3, [r3, #12]
  b8:	461a      	mov	r2, r3
  ba:	69fb      	ldr	r3, [r7, #28]
  bc:	ea43 0302 	orr.w	r3, r3, r2
  c0:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:231
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
  c2:	69fb      	ldr	r3, [r7, #28]
  c4:	b29b      	uxth	r3, r3
  c6:	687a      	ldr	r2, [r7, #4]
  c8:	8293      	strh	r3, [r2, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:235

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  ca:	f107 0308 	add.w	r3, r7, #8	; 0x8
  ce:	4618      	mov	r0, r3
  d0:	f7ff fffe 	bl	0 <RCC_GetClocksFreq>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:236
  if (usartxbase == USART1_BASE)
  d4:	6afa      	ldr	r2, [r7, #44]
  d6:	f643 0300 	movw	r3, #14336	; 0x3800
  da:	f2c4 0301 	movt	r3, #16385	; 0x4001
  de:	429a      	cmp	r2, r3
  e0:	d102      	bne.n	e8 <RCC_GetClocksFreq+0xe8>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:238
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
  e2:	697b      	ldr	r3, [r7, #20]
  e4:	623b      	str	r3, [r7, #32]
  e6:	e001      	b.n	ec <RCC_GetClocksFreq+0xec>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:242
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  e8:	693b      	ldr	r3, [r7, #16]
  ea:	623b      	str	r3, [r7, #32]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:246
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
  ec:	687b      	ldr	r3, [r7, #4]
  ee:	899b      	ldrh	r3, [r3, #12]
  f0:	b29b      	uxth	r3, r3
  f2:	b21b      	sxth	r3, r3
  f4:	2b00      	cmp	r3, #0
  f6:	da11      	bge.n	11c <RCC_GetClocksFreq+0x11c>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:249
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
  f8:	6a39      	ldr	r1, [r7, #32]
  fa:	460b      	mov	r3, r1
  fc:	ea4f 02c3 	mov.w	r2, r3, lsl #3
 100:	ea4f 0382 	mov.w	r3, r2, lsl #2
 104:	ebc2 0303 	rsb	r3, r2, r3
 108:	eb03 0201 	add.w	r2, r3, r1
 10c:	683b      	ldr	r3, [r7, #0]
 10e:	681b      	ldr	r3, [r3, #0]
 110:	ea4f 0343 	mov.w	r3, r3, lsl #1
 114:	fbb2 f3f3 	udiv	r3, r2, r3
 118:	627b      	str	r3, [r7, #36]
 11a:	e010      	b.n	13e <RCC_GetClocksFreq+0x13e>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:254
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 11c:	6a39      	ldr	r1, [r7, #32]
 11e:	460b      	mov	r3, r1
 120:	ea4f 02c3 	mov.w	r2, r3, lsl #3
 124:	ea4f 0382 	mov.w	r3, r2, lsl #2
 128:	ebc2 0303 	rsb	r3, r2, r3
 12c:	eb03 0201 	add.w	r2, r3, r1
 130:	683b      	ldr	r3, [r7, #0]
 132:	681b      	ldr	r3, [r3, #0]
 134:	ea4f 0383 	mov.w	r3, r3, lsl #2
 138:	fbb2 f3f3 	udiv	r3, r2, r3
 13c:	627b      	str	r3, [r7, #36]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:256
  }
  tmpreg = (integerdivider / 100) << 4;
 13e:	6a7a      	ldr	r2, [r7, #36]
 140:	f248 531f 	movw	r3, #34079	; 0x851f
 144:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 148:	fba3 1302 	umull	r1, r3, r3, r2
 14c:	ea4f 1353 	mov.w	r3, r3, lsr #5
 150:	ea4f 1303 	mov.w	r3, r3, lsl #4
 154:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:259

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 156:	69fb      	ldr	r3, [r7, #28]
 158:	ea4f 1313 	mov.w	r3, r3, lsr #4
 15c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 160:	ea4f 0283 	mov.w	r2, r3, lsl #2
 164:	4413      	add	r3, r2
 166:	ea4f 0283 	mov.w	r2, r3, lsl #2
 16a:	441a      	add	r2, r3
 16c:	6a7b      	ldr	r3, [r7, #36]
 16e:	ebc2 0303 	rsb	r3, r2, r3
 172:	62bb      	str	r3, [r7, #40]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:262

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 174:	687b      	ldr	r3, [r7, #4]
 176:	899b      	ldrh	r3, [r3, #12]
 178:	b29b      	uxth	r3, r3
 17a:	b21b      	sxth	r3, r3
 17c:	2b00      	cmp	r3, #0
 17e:	da13      	bge.n	1a8 <RCC_GetClocksFreq+0x1a8>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:264
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 180:	6abb      	ldr	r3, [r7, #40]
 182:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 186:	f103 0232 	add.w	r2, r3, #50	; 0x32
 18a:	f248 531f 	movw	r3, #34079	; 0x851f
 18e:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 192:	fba3 1302 	umull	r1, r3, r3, r2
 196:	ea4f 1353 	mov.w	r3, r3, lsr #5
 19a:	f003 0207 	and.w	r2, r3, #7	; 0x7
 19e:	69fb      	ldr	r3, [r7, #28]
 1a0:	ea43 0302 	orr.w	r3, r3, r2
 1a4:	61fb      	str	r3, [r7, #28]
 1a6:	e012      	b.n	1ce <RCC_GetClocksFreq+0x1ce>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:268
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 1a8:	6abb      	ldr	r3, [r7, #40]
 1aa:	ea4f 1303 	mov.w	r3, r3, lsl #4
 1ae:	f103 0232 	add.w	r2, r3, #50	; 0x32
 1b2:	f248 531f 	movw	r3, #34079	; 0x851f
 1b6:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 1ba:	fba3 1302 	umull	r1, r3, r3, r2
 1be:	ea4f 1353 	mov.w	r3, r3, lsr #5
 1c2:	f003 020f 	and.w	r2, r3, #15	; 0xf
 1c6:	69fb      	ldr	r3, [r7, #28]
 1c8:	ea43 0302 	orr.w	r3, r3, r2
 1cc:	61fb      	str	r3, [r7, #28]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:272
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 1ce:	69fb      	ldr	r3, [r7, #28]
 1d0:	b29b      	uxth	r3, r3
 1d2:	687a      	ldr	r2, [r7, #4]
 1d4:	8113      	strh	r3, [r2, #8]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:273
}
 1d6:	f107 0730 	add.w	r7, r7, #48	; 0x30
 1da:	46bd      	mov	sp, r7
 1dc:	bd80      	pop	{r7, pc}
 1de:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_StructInit:

00000000 <USART_StructInit>:
USART_StructInit():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:282
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         which will be initialized.
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:284
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
   8:	687a      	ldr	r2, [r7, #4]
   a:	f44f 5316 	mov.w	r3, #9600	; 0x2580
   e:	6013      	str	r3, [r2, #0]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:285
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  10:	687a      	ldr	r2, [r7, #4]
  12:	f04f 0300 	mov.w	r3, #0	; 0x0
  16:	8093      	strh	r3, [r2, #4]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:286
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  18:	687a      	ldr	r2, [r7, #4]
  1a:	f04f 0300 	mov.w	r3, #0	; 0x0
  1e:	80d3      	strh	r3, [r2, #6]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:287
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  20:	687a      	ldr	r2, [r7, #4]
  22:	f04f 0300 	mov.w	r3, #0	; 0x0
  26:	8113      	strh	r3, [r2, #8]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:288
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
  28:	687a      	ldr	r2, [r7, #4]
  2a:	f04f 030c 	mov.w	r3, #12	; 0xc
  2e:	8153      	strh	r3, [r2, #10]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:289
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
  30:	687a      	ldr	r2, [r7, #4]
  32:	f04f 0300 	mov.w	r3, #0	; 0x0
  36:	8193      	strh	r3, [r2, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:290
}
  38:	f107 070c 	add.w	r7, r7, #12	; 0xc
  3c:	46bd      	mov	sp, r7
  3e:	bc80      	pop	{r7}
  40:	4770      	bx	lr
  42:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_ClockInit:

00000000 <USART_ClockInit>:
USART_ClockInit():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:303
  *         USART peripheral.  
  * @note The Smart Card and Synchronous modes are not available for UART4 and UART5.
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:304
  uint32_t tmpreg = 0x00;
   a:	f04f 0300 	mov.w	r3, #0	; 0x0
   e:	60fb      	str	r3, [r7, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:313
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  10:	687b      	ldr	r3, [r7, #4]
  12:	8a1b      	ldrh	r3, [r3, #16]
  14:	b29b      	uxth	r3, r3
  16:	60fb      	str	r3, [r7, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:315
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= CR2_CLOCK_CLEAR_Mask;
  18:	68fa      	ldr	r2, [r7, #12]
  1a:	f24f 03ff 	movw	r3, #61695	; 0xf0ff
  1e:	f2c0 0300 	movt	r3, #0	; 0x0
  22:	ea02 0303 	and.w	r3, r2, r3
  26:	60fb      	str	r3, [r7, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:321
  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
  28:	683b      	ldr	r3, [r7, #0]
  2a:	881a      	ldrh	r2, [r3, #0]
  2c:	683b      	ldr	r3, [r7, #0]
  2e:	885b      	ldrh	r3, [r3, #2]
  30:	ea42 0303 	orr.w	r3, r2, r3
  34:	b29a      	uxth	r2, r3
  36:	683b      	ldr	r3, [r7, #0]
  38:	889b      	ldrh	r3, [r3, #4]
  3a:	ea42 0303 	orr.w	r3, r2, r3
  3e:	b29a      	uxth	r2, r3
  40:	683b      	ldr	r3, [r7, #0]
  42:	88db      	ldrh	r3, [r3, #6]
  44:	ea42 0303 	orr.w	r3, r2, r3
  48:	b29b      	uxth	r3, r3
  4a:	461a      	mov	r2, r3
  4c:	68fb      	ldr	r3, [r7, #12]
  4e:	ea43 0302 	orr.w	r3, r3, r2
  52:	60fb      	str	r3, [r7, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:324
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
  54:	68fb      	ldr	r3, [r7, #12]
  56:	b29b      	uxth	r3, r3
  58:	687a      	ldr	r2, [r7, #4]
  5a:	8213      	strh	r3, [r2, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:325
}
  5c:	f107 0714 	add.w	r7, r7, #20	; 0x14
  60:	46bd      	mov	sp, r7
  62:	bc80      	pop	{r7}
  64:	4770      	bx	lr
  66:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_ClockStructInit:

00000000 <USART_ClockStructInit>:
USART_ClockStructInit():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:334
  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
  *         structure which will be initialized.
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:336
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
   8:	687a      	ldr	r2, [r7, #4]
   a:	f04f 0300 	mov.w	r3, #0	; 0x0
   e:	8013      	strh	r3, [r2, #0]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:337
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
  10:	687a      	ldr	r2, [r7, #4]
  12:	f04f 0300 	mov.w	r3, #0	; 0x0
  16:	8053      	strh	r3, [r2, #2]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:338
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
  18:	687a      	ldr	r2, [r7, #4]
  1a:	f04f 0300 	mov.w	r3, #0	; 0x0
  1e:	8093      	strh	r3, [r2, #4]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:339
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
  20:	687a      	ldr	r2, [r7, #4]
  22:	f04f 0300 	mov.w	r3, #0	; 0x0
  26:	80d3      	strh	r3, [r2, #6]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:340
}
  28:	f107 070c 	add.w	r7, r7, #12	; 0xc
  2c:	46bd      	mov	sp, r7
  2e:	bc80      	pop	{r7}
  30:	4770      	bx	lr
  32:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_Cmd:

00000000 <USART_Cmd>:
USART_Cmd():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:352
  * @param  NewState: new state of the USARTx peripheral.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	72fb      	strb	r3, [r7, #11]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:357
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   c:	7afb      	ldrb	r3, [r7, #11]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <RCC_GetClocksFreq+0x24>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:360
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
  12:	68fb      	ldr	r3, [r7, #12]
  14:	899b      	ldrh	r3, [r3, #12]
  16:	b29b      	uxth	r3, r3
  18:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  1c:	b29b      	uxth	r3, r3
  1e:	68fa      	ldr	r2, [r7, #12]
  20:	8193      	strh	r3, [r2, #12]
  22:	e00f      	b.n	44 <RCC_GetClocksFreq+0x44>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:365
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
  24:	68fb      	ldr	r3, [r7, #12]
  26:	899b      	ldrh	r3, [r3, #12]
  28:	b29b      	uxth	r3, r3
  2a:	607b      	str	r3, [r7, #4]
  2c:	f64d 73ff 	movw	r3, #57343	; 0xdfff
  30:	f2c0 0300 	movt	r3, #0	; 0x0
  34:	6879      	ldr	r1, [r7, #4]
  36:	ea01 0303 	and.w	r3, r1, r3
  3a:	607b      	str	r3, [r7, #4]
  3c:	68fa      	ldr	r2, [r7, #12]
  3e:	6879      	ldr	r1, [r7, #4]
  40:	460b      	mov	r3, r1
  42:	8193      	strh	r3, [r2, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:367
  }
}
  44:	f107 0714 	add.w	r7, r7, #20	; 0x14
  48:	46bd      	mov	sp, r7
  4a:	bc80      	pop	{r7}
  4c:	4770      	bx	lr
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_ITConfig:

00000000 <USART_ITConfig>:
USART_ITConfig():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:389
  * @param  NewState: new state of the specified USARTx interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
   c:	4613      	mov	r3, r2
   e:	707b      	strb	r3, [r7, #1]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:390
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
  10:	f04f 0300 	mov.w	r3, #0	; 0x0
  14:	60bb      	str	r3, [r7, #8]
  16:	f04f 0300 	mov.w	r3, #0	; 0x0
  1a:	60fb      	str	r3, [r7, #12]
  1c:	f04f 0300 	mov.w	r3, #0	; 0x0
  20:	613b      	str	r3, [r7, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:391
  uint32_t usartxbase = 0x00;
  22:	f04f 0300 	mov.w	r3, #0	; 0x0
  26:	617b      	str	r3, [r7, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:402
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  usartxbase = (uint32_t)USARTx;
  28:	687b      	ldr	r3, [r7, #4]
  2a:	617b      	str	r3, [r7, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:405

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  2c:	887b      	ldrh	r3, [r7, #2]
  2e:	b2db      	uxtb	r3, r3
  30:	ea4f 1353 	mov.w	r3, r3, lsr #5
  34:	b2db      	uxtb	r3, r3
  36:	60bb      	str	r3, [r7, #8]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:408

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  38:	887b      	ldrh	r3, [r7, #2]
  3a:	f003 031f 	and.w	r3, r3, #31	; 0x1f
  3e:	60fb      	str	r3, [r7, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:409
  itmask = (((uint32_t)0x01) << itpos);
  40:	68fa      	ldr	r2, [r7, #12]
  42:	f04f 0301 	mov.w	r3, #1	; 0x1
  46:	fa03 f302 	lsl.w	r3, r3, r2
  4a:	613b      	str	r3, [r7, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:411
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
  4c:	68bb      	ldr	r3, [r7, #8]
  4e:	2b01      	cmp	r3, #1
  50:	d104      	bne.n	5c <RCC_GetClocksFreq+0x5c>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:413
  {
    usartxbase += 0x0C;
  52:	697b      	ldr	r3, [r7, #20]
  54:	f103 030c 	add.w	r3, r3, #12	; 0xc
  58:	617b      	str	r3, [r7, #20]
  5a:	e00b      	b.n	74 <RCC_GetClocksFreq+0x74>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:415
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
  5c:	68bb      	ldr	r3, [r7, #8]
  5e:	2b02      	cmp	r3, #2
  60:	d104      	bne.n	6c <RCC_GetClocksFreq+0x6c>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:417
  {
    usartxbase += 0x10;
  62:	697b      	ldr	r3, [r7, #20]
  64:	f103 0310 	add.w	r3, r3, #16	; 0x10
  68:	617b      	str	r3, [r7, #20]
  6a:	e003      	b.n	74 <RCC_GetClocksFreq+0x74>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:421
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
  6c:	697b      	ldr	r3, [r7, #20]
  6e:	f103 0314 	add.w	r3, r3, #20	; 0x14
  72:	617b      	str	r3, [r7, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:423
  }
  if (NewState != DISABLE)
  74:	787b      	ldrb	r3, [r7, #1]
  76:	2b00      	cmp	r3, #0
  78:	d007      	beq.n	8a <RCC_GetClocksFreq+0x8a>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:425
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  7a:	6979      	ldr	r1, [r7, #20]
  7c:	697b      	ldr	r3, [r7, #20]
  7e:	681a      	ldr	r2, [r3, #0]
  80:	693b      	ldr	r3, [r7, #16]
  82:	ea42 0303 	orr.w	r3, r2, r3
  86:	600b      	str	r3, [r1, #0]
  88:	e008      	b.n	9c <RCC_GetClocksFreq+0x9c>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:429
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  8a:	6979      	ldr	r1, [r7, #20]
  8c:	697b      	ldr	r3, [r7, #20]
  8e:	681a      	ldr	r2, [r3, #0]
  90:	693b      	ldr	r3, [r7, #16]
  92:	ea6f 0303 	mvn.w	r3, r3
  96:	ea02 0303 	and.w	r3, r2, r3
  9a:	600b      	str	r3, [r1, #0]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:431
  }
}
  9c:	f107 071c 	add.w	r7, r7, #28	; 0x1c
  a0:	46bd      	mov	sp, r7
  a2:	bc80      	pop	{r7}
  a4:	4770      	bx	lr
  a6:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_DMACmd:

00000000 <USART_DMACmd>:
USART_DMACmd():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:449
  * @note The DMA mode is not available for UART5 except in the STM32
  *       High density value line devices(STM32F10X_HD_VL).  
  * @retval None
  */
void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
   c:	4613      	mov	r3, r2
   e:	707b      	strb	r3, [r7, #1]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:454
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  if (NewState != DISABLE)
  10:	787b      	ldrb	r3, [r7, #1]
  12:	2b00      	cmp	r3, #0
  14:	d009      	beq.n	2a <RCC_GetClocksFreq+0x2a>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:458
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
  16:	687b      	ldr	r3, [r7, #4]
  18:	8a9b      	ldrh	r3, [r3, #20]
  1a:	b29a      	uxth	r2, r3
  1c:	887b      	ldrh	r3, [r7, #2]
  1e:	ea42 0303 	orr.w	r3, r2, r3
  22:	b29b      	uxth	r3, r3
  24:	687a      	ldr	r2, [r7, #4]
  26:	8293      	strh	r3, [r2, #20]
  28:	e00b      	b.n	42 <RCC_GetClocksFreq+0x42>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:464
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
  2a:	687b      	ldr	r3, [r7, #4]
  2c:	8a9b      	ldrh	r3, [r3, #20]
  2e:	b29a      	uxth	r2, r3
  30:	887b      	ldrh	r3, [r7, #2]
  32:	ea6f 0303 	mvn.w	r3, r3
  36:	b29b      	uxth	r3, r3
  38:	ea02 0303 	and.w	r3, r2, r3
  3c:	b29b      	uxth	r3, r3
  3e:	687a      	ldr	r2, [r7, #4]
  40:	8293      	strh	r3, [r2, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:466
  }
}
  42:	f107 070c 	add.w	r7, r7, #12	; 0xc
  46:	46bd      	mov	sp, r7
  48:	bc80      	pop	{r7}
  4a:	4770      	bx	lr
Disassembly of section .text.USART_SetAddress:

00000000 <USART_SetAddress>:
USART_SetAddress():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:477
  *   USART1, USART2, USART3, UART4 or UART5.
  * @param  USART_Address: Indicates the address of the USART node.
  * @retval None
  */
void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	72fb      	strb	r3, [r7, #11]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:483
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS(USART_Address)); 
    
  /* Clear the USART address */
  USARTx->CR2 &= CR2_Address_Mask;
   c:	68fb      	ldr	r3, [r7, #12]
   e:	8a1b      	ldrh	r3, [r3, #16]
  10:	b29b      	uxth	r3, r3
  12:	607b      	str	r3, [r7, #4]
  14:	f64f 73f0 	movw	r3, #65520	; 0xfff0
  18:	f2c0 0300 	movt	r3, #0	; 0x0
  1c:	6879      	ldr	r1, [r7, #4]
  1e:	ea01 0303 	and.w	r3, r1, r3
  22:	607b      	str	r3, [r7, #4]
  24:	68fa      	ldr	r2, [r7, #12]
  26:	6879      	ldr	r1, [r7, #4]
  28:	460b      	mov	r3, r1
  2a:	8213      	strh	r3, [r2, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:485
  /* Set the USART address node */
  USARTx->CR2 |= USART_Address;
  2c:	68fb      	ldr	r3, [r7, #12]
  2e:	8a1b      	ldrh	r3, [r3, #16]
  30:	b29a      	uxth	r2, r3
  32:	7afb      	ldrb	r3, [r7, #11]
  34:	ea42 0303 	orr.w	r3, r2, r3
  38:	b29b      	uxth	r3, r3
  3a:	68fa      	ldr	r2, [r7, #12]
  3c:	8213      	strh	r3, [r2, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:486
}
  3e:	f107 0714 	add.w	r7, r7, #20	; 0x14
  42:	46bd      	mov	sp, r7
  44:	bc80      	pop	{r7}
  46:	4770      	bx	lr
Disassembly of section .text.USART_WakeUpConfig:

00000000 <USART_WakeUpConfig>:
USART_WakeUpConfig():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:500
  *     @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
  *     @arg USART_WakeUp_AddressMark: WakeUp by an address mark
  * @retval None
  */
void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	817b      	strh	r3, [r7, #10]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:505
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_WAKEUP(USART_WakeUp));
  
  USARTx->CR1 &= CR1_WAKE_Mask;
   c:	68fb      	ldr	r3, [r7, #12]
   e:	899b      	ldrh	r3, [r3, #12]
  10:	b29b      	uxth	r3, r3
  12:	607b      	str	r3, [r7, #4]
  14:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
  18:	f2c0 0300 	movt	r3, #0	; 0x0
  1c:	6879      	ldr	r1, [r7, #4]
  1e:	ea01 0303 	and.w	r3, r1, r3
  22:	607b      	str	r3, [r7, #4]
  24:	68fa      	ldr	r2, [r7, #12]
  26:	6879      	ldr	r1, [r7, #4]
  28:	460b      	mov	r3, r1
  2a:	8193      	strh	r3, [r2, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:506
  USARTx->CR1 |= USART_WakeUp;
  2c:	68fb      	ldr	r3, [r7, #12]
  2e:	899b      	ldrh	r3, [r3, #12]
  30:	b29a      	uxth	r2, r3
  32:	897b      	ldrh	r3, [r7, #10]
  34:	ea42 0303 	orr.w	r3, r2, r3
  38:	b29b      	uxth	r3, r3
  3a:	68fa      	ldr	r2, [r7, #12]
  3c:	8193      	strh	r3, [r2, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:507
}
  3e:	f107 0714 	add.w	r7, r7, #20	; 0x14
  42:	46bd      	mov	sp, r7
  44:	bc80      	pop	{r7}
  46:	4770      	bx	lr
Disassembly of section .text.USART_ReceiverWakeUpCmd:

00000000 <USART_ReceiverWakeUpCmd>:
USART_ReceiverWakeUpCmd():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:519
  * @param  NewState: new state of the USART mute mode.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	72fb      	strb	r3, [r7, #11]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:524
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
   c:	7afb      	ldrb	r3, [r7, #11]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <RCC_GetClocksFreq+0x24>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:527
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= CR1_RWU_Set;
  12:	68fb      	ldr	r3, [r7, #12]
  14:	899b      	ldrh	r3, [r3, #12]
  16:	b29b      	uxth	r3, r3
  18:	f043 0302 	orr.w	r3, r3, #2	; 0x2
  1c:	b29b      	uxth	r3, r3
  1e:	68fa      	ldr	r2, [r7, #12]
  20:	8193      	strh	r3, [r2, #12]
  22:	e00f      	b.n	44 <RCC_GetClocksFreq+0x44>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:532
  }
  else
  {
    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    USARTx->CR1 &= CR1_RWU_Reset;
  24:	68fb      	ldr	r3, [r7, #12]
  26:	899b      	ldrh	r3, [r3, #12]
  28:	b29b      	uxth	r3, r3
  2a:	607b      	str	r3, [r7, #4]
  2c:	f64f 73fd 	movw	r3, #65533	; 0xfffd
  30:	f2c0 0300 	movt	r3, #0	; 0x0
  34:	6879      	ldr	r1, [r7, #4]
  36:	ea01 0303 	and.w	r3, r1, r3
  3a:	607b      	str	r3, [r7, #4]
  3c:	68fa      	ldr	r2, [r7, #12]
  3e:	6879      	ldr	r1, [r7, #4]
  40:	460b      	mov	r3, r1
  42:	8193      	strh	r3, [r2, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:534
  }
}
  44:	f107 0714 	add.w	r7, r7, #20	; 0x14
  48:	46bd      	mov	sp, r7
  4a:	bc80      	pop	{r7}
  4c:	4770      	bx	lr
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_LINBreakDetectLengthConfig:

00000000 <USART_LINBreakDetectLengthConfig>:
USART_LINBreakDetectLengthConfig():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:548
  *     @arg USART_LINBreakDetectLength_10b: 10-bit break detection
  *     @arg USART_LINBreakDetectLength_11b: 11-bit break detection
  * @retval None
  */
void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	817b      	strh	r3, [r7, #10]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:553
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
  
  USARTx->CR2 &= CR2_LBDL_Mask;
   c:	68fb      	ldr	r3, [r7, #12]
   e:	8a1b      	ldrh	r3, [r3, #16]
  10:	b29b      	uxth	r3, r3
  12:	607b      	str	r3, [r7, #4]
  14:	f64f 73df 	movw	r3, #65503	; 0xffdf
  18:	f2c0 0300 	movt	r3, #0	; 0x0
  1c:	6879      	ldr	r1, [r7, #4]
  1e:	ea01 0303 	and.w	r3, r1, r3
  22:	607b      	str	r3, [r7, #4]
  24:	68fa      	ldr	r2, [r7, #12]
  26:	6879      	ldr	r1, [r7, #4]
  28:	460b      	mov	r3, r1
  2a:	8213      	strh	r3, [r2, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:554
  USARTx->CR2 |= USART_LINBreakDetectLength;  
  2c:	68fb      	ldr	r3, [r7, #12]
  2e:	8a1b      	ldrh	r3, [r3, #16]
  30:	b29a      	uxth	r2, r3
  32:	897b      	ldrh	r3, [r7, #10]
  34:	ea42 0303 	orr.w	r3, r2, r3
  38:	b29b      	uxth	r3, r3
  3a:	68fa      	ldr	r2, [r7, #12]
  3c:	8213      	strh	r3, [r2, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:555
}
  3e:	f107 0714 	add.w	r7, r7, #20	; 0x14
  42:	46bd      	mov	sp, r7
  44:	bc80      	pop	{r7}
  46:	4770      	bx	lr
Disassembly of section .text.USART_LINCmd:

00000000 <USART_LINCmd>:
USART_LINCmd():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:567
  * @param  NewState: new state of the USART LIN mode.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	72fb      	strb	r3, [r7, #11]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:572
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   c:	7afb      	ldrb	r3, [r7, #11]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <RCC_GetClocksFreq+0x24>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:575
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= CR2_LINEN_Set;
  12:	68fb      	ldr	r3, [r7, #12]
  14:	8a1b      	ldrh	r3, [r3, #16]
  16:	b29b      	uxth	r3, r3
  18:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  1c:	b29b      	uxth	r3, r3
  1e:	68fa      	ldr	r2, [r7, #12]
  20:	8213      	strh	r3, [r2, #16]
  22:	e00f      	b.n	44 <RCC_GetClocksFreq+0x44>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:580
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= CR2_LINEN_Reset;
  24:	68fb      	ldr	r3, [r7, #12]
  26:	8a1b      	ldrh	r3, [r3, #16]
  28:	b29b      	uxth	r3, r3
  2a:	607b      	str	r3, [r7, #4]
  2c:	f64b 73ff 	movw	r3, #49151	; 0xbfff
  30:	f2c0 0300 	movt	r3, #0	; 0x0
  34:	6879      	ldr	r1, [r7, #4]
  36:	ea01 0303 	and.w	r3, r1, r3
  3a:	607b      	str	r3, [r7, #4]
  3c:	68fa      	ldr	r2, [r7, #12]
  3e:	6879      	ldr	r1, [r7, #4]
  40:	460b      	mov	r3, r1
  42:	8213      	strh	r3, [r2, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:582
  }
}
  44:	f107 0714 	add.w	r7, r7, #20	; 0x14
  48:	46bd      	mov	sp, r7
  4a:	bc80      	pop	{r7}
  4c:	4770      	bx	lr
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_SendData:

00000000 <USART_SendData>:
USART_SendData():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:593
  *   USART1, USART2, USART3, UART4 or UART5.
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	817b      	strh	r3, [r7, #10]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:599
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
   c:	8979      	ldrh	r1, [r7, #10]
   e:	6079      	str	r1, [r7, #4]
  10:	687a      	ldr	r2, [r7, #4]
  12:	ea4f 53c2 	mov.w	r3, r2, lsl #23
  16:	ea4f 53d3 	mov.w	r3, r3, lsr #23
  1a:	607b      	str	r3, [r7, #4]
  1c:	68fa      	ldr	r2, [r7, #12]
  1e:	6879      	ldr	r1, [r7, #4]
  20:	460b      	mov	r3, r1
  22:	8093      	strh	r3, [r2, #4]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:600
}
  24:	f107 0714 	add.w	r7, r7, #20	; 0x14
  28:	46bd      	mov	sp, r7
  2a:	bc80      	pop	{r7}
  2c:	4770      	bx	lr
  2e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_ReceiveData:

00000000 <USART_ReceiveData>:
USART_ReceiveData():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:610
  *   This parameter can be one of the following values:
  *   USART1, USART2, USART3, UART4 or UART5.
  * @retval The received data.
  */
uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:615
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
   8:	687b      	ldr	r3, [r7, #4]
   a:	889b      	ldrh	r3, [r3, #4]
   c:	b29b      	uxth	r3, r3
   e:	603b      	str	r3, [r7, #0]
  10:	683a      	ldr	r2, [r7, #0]
  12:	ea4f 53c2 	mov.w	r3, r2, lsl #23
  16:	ea4f 53d3 	mov.w	r3, r3, lsr #23
  1a:	603b      	str	r3, [r7, #0]
  1c:	683b      	ldr	r3, [r7, #0]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:616
}
  1e:	4618      	mov	r0, r3
  20:	f107 070c 	add.w	r7, r7, #12	; 0xc
  24:	46bd      	mov	sp, r7
  26:	bc80      	pop	{r7}
  28:	4770      	bx	lr
  2a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_SendBreak:

00000000 <USART_SendBreak>:
USART_SendBreak():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:626
  *   This parameter can be one of the following values:
  *   USART1, USART2, USART3, UART4 or UART5.
  * @retval None
  */
void USART_SendBreak(USART_TypeDef* USARTx)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:631
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Send break characters */
  USARTx->CR1 |= CR1_SBK_Set;
   8:	687b      	ldr	r3, [r7, #4]
   a:	899b      	ldrh	r3, [r3, #12]
   c:	b29b      	uxth	r3, r3
   e:	f043 0301 	orr.w	r3, r3, #1	; 0x1
  12:	b29b      	uxth	r3, r3
  14:	687a      	ldr	r2, [r7, #4]
  16:	8193      	strh	r3, [r2, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:632
}
  18:	f107 070c 	add.w	r7, r7, #12	; 0xc
  1c:	46bd      	mov	sp, r7
  1e:	bc80      	pop	{r7}
  20:	4770      	bx	lr
  22:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_SetGuardTime:

00000000 <USART_SetGuardTime>:
USART_SetGuardTime():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:642
  * @param  USART_GuardTime: specifies the guard time.
  * @note The guard time bits are not available for UART4 and UART5.   
  * @retval None
  */
void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
{    
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:647
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  
  /* Clear the USART Guard time */
  USARTx->GTPR &= GTPR_LSB_Mask;
   c:	687b      	ldr	r3, [r7, #4]
   e:	8b1b      	ldrh	r3, [r3, #24]
  10:	b29b      	uxth	r3, r3
  12:	f003 03ff 	and.w	r3, r3, #255	; 0xff
  16:	687a      	ldr	r2, [r7, #4]
  18:	8313      	strh	r3, [r2, #24]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:649
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
  1a:	687b      	ldr	r3, [r7, #4]
  1c:	8b1b      	ldrh	r3, [r3, #24]
  1e:	b29a      	uxth	r2, r3
  20:	78fb      	ldrb	r3, [r7, #3]
  22:	ea4f 2303 	mov.w	r3, r3, lsl #8
  26:	b29b      	uxth	r3, r3
  28:	ea42 0303 	orr.w	r3, r2, r3
  2c:	b29b      	uxth	r3, r3
  2e:	687a      	ldr	r2, [r7, #4]
  30:	8313      	strh	r3, [r2, #24]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:650
}
  32:	f107 070c 	add.w	r7, r7, #12	; 0xc
  36:	46bd      	mov	sp, r7
  38:	bc80      	pop	{r7}
  3a:	4770      	bx	lr
Disassembly of section .text.USART_SetPrescaler:

00000000 <USART_SetPrescaler>:
USART_SetPrescaler():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:662
  * @param  USART_Prescaler: specifies the prescaler clock.  
  * @note   The function is used for IrDA mode with UART4 and UART5.
  * @retval None
  */
void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
{ 
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:667
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART prescaler */
  USARTx->GTPR &= GTPR_MSB_Mask;
   c:	687b      	ldr	r3, [r7, #4]
   e:	8b1b      	ldrh	r3, [r3, #24]
  10:	b29b      	uxth	r3, r3
  12:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  16:	687a      	ldr	r2, [r7, #4]
  18:	8313      	strh	r3, [r2, #24]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:669
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
  1a:	687b      	ldr	r3, [r7, #4]
  1c:	8b1b      	ldrh	r3, [r3, #24]
  1e:	b29a      	uxth	r2, r3
  20:	78fb      	ldrb	r3, [r7, #3]
  22:	ea42 0303 	orr.w	r3, r2, r3
  26:	b29b      	uxth	r3, r3
  28:	687a      	ldr	r2, [r7, #4]
  2a:	8313      	strh	r3, [r2, #24]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:670
}
  2c:	f107 070c 	add.w	r7, r7, #12	; 0xc
  30:	46bd      	mov	sp, r7
  32:	bc80      	pop	{r7}
  34:	4770      	bx	lr
  36:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_SmartCardCmd:

00000000 <USART_SmartCardCmd>:
USART_SmartCardCmd():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:681
  *   This parameter can be: ENABLE or DISABLE.     
  * @note The Smart Card mode is not available for UART4 and UART5. 
  * @retval None
  */
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	72fb      	strb	r3, [r7, #11]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:685
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	7afb      	ldrb	r3, [r7, #11]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <RCC_GetClocksFreq+0x24>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:688
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= CR3_SCEN_Set;
  12:	68fb      	ldr	r3, [r7, #12]
  14:	8a9b      	ldrh	r3, [r3, #20]
  16:	b29b      	uxth	r3, r3
  18:	f043 0320 	orr.w	r3, r3, #32	; 0x20
  1c:	b29b      	uxth	r3, r3
  1e:	68fa      	ldr	r2, [r7, #12]
  20:	8293      	strh	r3, [r2, #20]
  22:	e00f      	b.n	44 <RCC_GetClocksFreq+0x44>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:693
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= CR3_SCEN_Reset;
  24:	68fb      	ldr	r3, [r7, #12]
  26:	8a9b      	ldrh	r3, [r3, #20]
  28:	b29b      	uxth	r3, r3
  2a:	607b      	str	r3, [r7, #4]
  2c:	f64f 73df 	movw	r3, #65503	; 0xffdf
  30:	f2c0 0300 	movt	r3, #0	; 0x0
  34:	6879      	ldr	r1, [r7, #4]
  36:	ea01 0303 	and.w	r3, r1, r3
  3a:	607b      	str	r3, [r7, #4]
  3c:	68fa      	ldr	r2, [r7, #12]
  3e:	6879      	ldr	r1, [r7, #4]
  40:	460b      	mov	r3, r1
  42:	8293      	strh	r3, [r2, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:695
  }
}
  44:	f107 0714 	add.w	r7, r7, #20	; 0x14
  48:	46bd      	mov	sp, r7
  4a:	bc80      	pop	{r7}
  4c:	4770      	bx	lr
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_SmartCardNACKCmd:

00000000 <USART_SmartCardNACKCmd>:
USART_SmartCardNACKCmd():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:706
  *   This parameter can be: ENABLE or DISABLE.  
  * @note The Smart Card mode is not available for UART4 and UART5.
  * @retval None
  */
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	72fb      	strb	r3, [r7, #11]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:710
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	7afb      	ldrb	r3, [r7, #11]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <RCC_GetClocksFreq+0x24>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:713
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= CR3_NACK_Set;
  12:	68fb      	ldr	r3, [r7, #12]
  14:	8a9b      	ldrh	r3, [r3, #20]
  16:	b29b      	uxth	r3, r3
  18:	f043 0310 	orr.w	r3, r3, #16	; 0x10
  1c:	b29b      	uxth	r3, r3
  1e:	68fa      	ldr	r2, [r7, #12]
  20:	8293      	strh	r3, [r2, #20]
  22:	e00f      	b.n	44 <RCC_GetClocksFreq+0x44>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:718
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= CR3_NACK_Reset;
  24:	68fb      	ldr	r3, [r7, #12]
  26:	8a9b      	ldrh	r3, [r3, #20]
  28:	b29b      	uxth	r3, r3
  2a:	607b      	str	r3, [r7, #4]
  2c:	f64f 73ef 	movw	r3, #65519	; 0xffef
  30:	f2c0 0300 	movt	r3, #0	; 0x0
  34:	6879      	ldr	r1, [r7, #4]
  36:	ea01 0303 	and.w	r3, r1, r3
  3a:	607b      	str	r3, [r7, #4]
  3c:	68fa      	ldr	r2, [r7, #12]
  3e:	6879      	ldr	r1, [r7, #4]
  40:	460b      	mov	r3, r1
  42:	8293      	strh	r3, [r2, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:720
  }
}
  44:	f107 0714 	add.w	r7, r7, #20	; 0x14
  48:	46bd      	mov	sp, r7
  4a:	bc80      	pop	{r7}
  4c:	4770      	bx	lr
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_HalfDuplexCmd:

00000000 <USART_HalfDuplexCmd>:
USART_HalfDuplexCmd():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:732
  * @param  NewState: new state of the USART Communication.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	72fb      	strb	r3, [r7, #11]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:737
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   c:	7afb      	ldrb	r3, [r7, #11]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <RCC_GetClocksFreq+0x24>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:740
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= CR3_HDSEL_Set;
  12:	68fb      	ldr	r3, [r7, #12]
  14:	8a9b      	ldrh	r3, [r3, #20]
  16:	b29b      	uxth	r3, r3
  18:	f043 0308 	orr.w	r3, r3, #8	; 0x8
  1c:	b29b      	uxth	r3, r3
  1e:	68fa      	ldr	r2, [r7, #12]
  20:	8293      	strh	r3, [r2, #20]
  22:	e00f      	b.n	44 <RCC_GetClocksFreq+0x44>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:745
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= CR3_HDSEL_Reset;
  24:	68fb      	ldr	r3, [r7, #12]
  26:	8a9b      	ldrh	r3, [r3, #20]
  28:	b29b      	uxth	r3, r3
  2a:	607b      	str	r3, [r7, #4]
  2c:	f64f 73f7 	movw	r3, #65527	; 0xfff7
  30:	f2c0 0300 	movt	r3, #0	; 0x0
  34:	6879      	ldr	r1, [r7, #4]
  36:	ea01 0303 	and.w	r3, r1, r3
  3a:	607b      	str	r3, [r7, #4]
  3c:	68fa      	ldr	r2, [r7, #12]
  3e:	6879      	ldr	r1, [r7, #4]
  40:	460b      	mov	r3, r1
  42:	8293      	strh	r3, [r2, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:747
  }
}
  44:	f107 0714 	add.w	r7, r7, #20	; 0x14
  48:	46bd      	mov	sp, r7
  4a:	bc80      	pop	{r7}
  4c:	4770      	bx	lr
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_OverSampling8Cmd:

00000000 <USART_OverSampling8Cmd>:
USART_OverSampling8Cmd():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:763
  *     This function has to be called before calling USART_Init()
  *     function in order to have correct baudrate Divider value.   
  * @retval None
  */
void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	72fb      	strb	r3, [r7, #11]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:768
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   c:	7afb      	ldrb	r3, [r7, #11]
   e:	2b00      	cmp	r3, #0
  10:	d00a      	beq.n	28 <RCC_GetClocksFreq+0x28>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:771
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= CR1_OVER8_Set;
  12:	68fb      	ldr	r3, [r7, #12]
  14:	899b      	ldrh	r3, [r3, #12]
  16:	b29b      	uxth	r3, r3
  18:	ea6f 4343 	mvn.w	r3, r3, lsl #17
  1c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
  20:	b29b      	uxth	r3, r3
  22:	68fa      	ldr	r2, [r7, #12]
  24:	8193      	strh	r3, [r2, #12]
  26:	e00d      	b.n	44 <RCC_GetClocksFreq+0x44>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:776
  }
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= CR1_OVER8_Reset;
  28:	68fb      	ldr	r3, [r7, #12]
  2a:	899b      	ldrh	r3, [r3, #12]
  2c:	b29b      	uxth	r3, r3
  2e:	607b      	str	r3, [r7, #4]
  30:	6879      	ldr	r1, [r7, #4]
  32:	ea4f 4341 	mov.w	r3, r1, lsl #17
  36:	ea4f 4353 	mov.w	r3, r3, lsr #17
  3a:	607b      	str	r3, [r7, #4]
  3c:	68fa      	ldr	r2, [r7, #12]
  3e:	6879      	ldr	r1, [r7, #4]
  40:	460b      	mov	r3, r1
  42:	8193      	strh	r3, [r2, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:778
  }
}
  44:	f107 0714 	add.w	r7, r7, #20	; 0x14
  48:	46bd      	mov	sp, r7
  4a:	bc80      	pop	{r7}
  4c:	4770      	bx	lr
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_OneBitMethodCmd:

00000000 <USART_OneBitMethodCmd>:
USART_OneBitMethodCmd():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:790
  * @param  NewState: new state of the USART one bit sampling method.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	72fb      	strb	r3, [r7, #11]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:795
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   c:	7afb      	ldrb	r3, [r7, #11]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <RCC_GetClocksFreq+0x24>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:798
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= CR3_ONEBITE_Set;
  12:	68fb      	ldr	r3, [r7, #12]
  14:	8a9b      	ldrh	r3, [r3, #20]
  16:	b29b      	uxth	r3, r3
  18:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  1c:	b29b      	uxth	r3, r3
  1e:	68fa      	ldr	r2, [r7, #12]
  20:	8293      	strh	r3, [r2, #20]
  22:	e00f      	b.n	44 <RCC_GetClocksFreq+0x44>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:803
  }
  else
  {
    /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= CR3_ONEBITE_Reset;
  24:	68fb      	ldr	r3, [r7, #12]
  26:	8a9b      	ldrh	r3, [r3, #20]
  28:	b29b      	uxth	r3, r3
  2a:	607b      	str	r3, [r7, #4]
  2c:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
  30:	f2c0 0300 	movt	r3, #0	; 0x0
  34:	6879      	ldr	r1, [r7, #4]
  36:	ea01 0303 	and.w	r3, r1, r3
  3a:	607b      	str	r3, [r7, #4]
  3c:	68fa      	ldr	r2, [r7, #12]
  3e:	6879      	ldr	r1, [r7, #4]
  40:	460b      	mov	r3, r1
  42:	8293      	strh	r3, [r2, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:805
  }
}
  44:	f107 0714 	add.w	r7, r7, #20	; 0x14
  48:	46bd      	mov	sp, r7
  4a:	bc80      	pop	{r7}
  4c:	4770      	bx	lr
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_IrDAConfig:

00000000 <USART_IrDAConfig>:
USART_IrDAConfig():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:819
  *     @arg USART_IrDAMode_LowPower
  *     @arg USART_IrDAMode_Normal
  * @retval None
  */
void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	817b      	strh	r3, [r7, #10]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:824
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
    
  USARTx->CR3 &= CR3_IRLP_Mask;
   c:	68fb      	ldr	r3, [r7, #12]
   e:	8a9b      	ldrh	r3, [r3, #20]
  10:	b29b      	uxth	r3, r3
  12:	607b      	str	r3, [r7, #4]
  14:	f64f 73fb 	movw	r3, #65531	; 0xfffb
  18:	f2c0 0300 	movt	r3, #0	; 0x0
  1c:	6879      	ldr	r1, [r7, #4]
  1e:	ea01 0303 	and.w	r3, r1, r3
  22:	607b      	str	r3, [r7, #4]
  24:	68fa      	ldr	r2, [r7, #12]
  26:	6879      	ldr	r1, [r7, #4]
  28:	460b      	mov	r3, r1
  2a:	8293      	strh	r3, [r2, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:825
  USARTx->CR3 |= USART_IrDAMode;
  2c:	68fb      	ldr	r3, [r7, #12]
  2e:	8a9b      	ldrh	r3, [r3, #20]
  30:	b29a      	uxth	r2, r3
  32:	897b      	ldrh	r3, [r7, #10]
  34:	ea42 0303 	orr.w	r3, r2, r3
  38:	b29b      	uxth	r3, r3
  3a:	68fa      	ldr	r2, [r7, #12]
  3c:	8293      	strh	r3, [r2, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:826
}
  3e:	f107 0714 	add.w	r7, r7, #20	; 0x14
  42:	46bd      	mov	sp, r7
  44:	bc80      	pop	{r7}
  46:	4770      	bx	lr
Disassembly of section .text.USART_IrDACmd:

00000000 <USART_IrDACmd>:
USART_IrDACmd():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:838
  * @param  NewState: new state of the IrDA mode.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	460b      	mov	r3, r1
   a:	72fb      	strb	r3, [r7, #11]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:843
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
   c:	7afb      	ldrb	r3, [r7, #11]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <RCC_GetClocksFreq+0x24>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:846
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= CR3_IREN_Set;
  12:	68fb      	ldr	r3, [r7, #12]
  14:	8a9b      	ldrh	r3, [r3, #20]
  16:	b29b      	uxth	r3, r3
  18:	f043 0302 	orr.w	r3, r3, #2	; 0x2
  1c:	b29b      	uxth	r3, r3
  1e:	68fa      	ldr	r2, [r7, #12]
  20:	8293      	strh	r3, [r2, #20]
  22:	e00f      	b.n	44 <RCC_GetClocksFreq+0x44>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:851
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= CR3_IREN_Reset;
  24:	68fb      	ldr	r3, [r7, #12]
  26:	8a9b      	ldrh	r3, [r3, #20]
  28:	b29b      	uxth	r3, r3
  2a:	607b      	str	r3, [r7, #4]
  2c:	f64f 73fd 	movw	r3, #65533	; 0xfffd
  30:	f2c0 0300 	movt	r3, #0	; 0x0
  34:	6879      	ldr	r1, [r7, #4]
  36:	ea01 0303 	and.w	r3, r1, r3
  3a:	607b      	str	r3, [r7, #4]
  3c:	68fa      	ldr	r2, [r7, #12]
  3e:	6879      	ldr	r1, [r7, #4]
  40:	460b      	mov	r3, r1
  42:	8293      	strh	r3, [r2, #20]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:853
  }
}
  44:	f107 0714 	add.w	r7, r7, #20	; 0x14
  48:	46bd      	mov	sp, r7
  4a:	bc80      	pop	{r7}
  4c:	4770      	bx	lr
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_GetFlagStatus:

00000000 <USART_GetFlagStatus>:
USART_GetFlagStatus():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:875
  *     @arg USART_FLAG_FE:   Framing Error flag
  *     @arg USART_FLAG_PE:   Parity Error flag
  * @retval The new state of USART_FLAG (SET or RESET).
  */
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:876
  FlagStatus bitstatus = RESET;
   c:	f04f 0300 	mov.w	r3, #0	; 0x0
  10:	73fb      	strb	r3, [r7, #15]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:886
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }  
  
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29a      	uxth	r2, r3
  18:	887b      	ldrh	r3, [r7, #2]
  1a:	ea02 0303 	and.w	r3, r2, r3
  1e:	b29b      	uxth	r3, r3
  20:	2b00      	cmp	r3, #0
  22:	d003      	beq.n	2c <RCC_GetClocksFreq+0x2c>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:888
  {
    bitstatus = SET;
  24:	f04f 0301 	mov.w	r3, #1	; 0x1
  28:	73fb      	strb	r3, [r7, #15]
  2a:	e002      	b.n	32 <RCC_GetClocksFreq+0x32>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:892
  }
  else
  {
    bitstatus = RESET;
  2c:	f04f 0300 	mov.w	r3, #0	; 0x0
  30:	73fb      	strb	r3, [r7, #15]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:894
  }
  return bitstatus;
  32:	7bfb      	ldrb	r3, [r7, #15]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:895
}
  34:	4618      	mov	r0, r3
  36:	f107 0714 	add.w	r7, r7, #20	; 0x14
  3a:	46bd      	mov	sp, r7
  3c:	bc80      	pop	{r7}
  3e:	4770      	bx	lr
Disassembly of section .text.USART_ClearFlag:

00000000 <USART_ClearFlag>:
USART_ClearFlag():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:924
  *   - TXE flag is cleared only by a write to the USART_DR register 
  *     (USART_SendData()).
  * @retval None
  */
void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:934
  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  } 
   
  USARTx->SR = (uint16_t)~USART_FLAG;
   c:	887b      	ldrh	r3, [r7, #2]
   e:	ea6f 0303 	mvn.w	r3, r3
  12:	b29b      	uxth	r3, r3
  14:	687a      	ldr	r2, [r7, #4]
  16:	8013      	strh	r3, [r2, #0]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:935
}
  18:	f107 070c 	add.w	r7, r7, #12	; 0xc
  1c:	46bd      	mov	sp, r7
  1e:	bc80      	pop	{r7}
  20:	4770      	bx	lr
  22:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_GetITStatus:

00000000 <USART_GetITStatus>:
USART_GetITStatus():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:957
  *     @arg USART_IT_FE:   Framing Error interrupt
  *     @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
   0:	b480      	push	{r7}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:958
  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
   c:	f04f 0300 	mov.w	r3, #0	; 0x0
  10:	60bb      	str	r3, [r7, #8]
  12:	f04f 0300 	mov.w	r3, #0	; 0x0
  16:	60fb      	str	r3, [r7, #12]
  18:	f04f 0300 	mov.w	r3, #0	; 0x0
  1c:	613b      	str	r3, [r7, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:959
  ITStatus bitstatus = RESET;
  1e:	f04f 0300 	mov.w	r3, #0	; 0x0
  22:	75fb      	strb	r3, [r7, #23]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:970
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  24:	887b      	ldrh	r3, [r7, #2]
  26:	b2db      	uxtb	r3, r3
  28:	ea4f 1353 	mov.w	r3, r3, lsr #5
  2c:	b2db      	uxtb	r3, r3
  2e:	613b      	str	r3, [r7, #16]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:972
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;
  30:	887b      	ldrh	r3, [r7, #2]
  32:	f003 031f 	and.w	r3, r3, #31	; 0x1f
  36:	60fb      	str	r3, [r7, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:973
  itmask = (uint32_t)0x01 << itmask;
  38:	68fa      	ldr	r2, [r7, #12]
  3a:	f04f 0301 	mov.w	r3, #1	; 0x1
  3e:	fa03 f302 	lsl.w	r3, r3, r2
  42:	60fb      	str	r3, [r7, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:975
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
  44:	693b      	ldr	r3, [r7, #16]
  46:	2b01      	cmp	r3, #1
  48:	d108      	bne.n	5c <RCC_GetClocksFreq+0x5c>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:977
  {
    itmask &= USARTx->CR1;
  4a:	687b      	ldr	r3, [r7, #4]
  4c:	899b      	ldrh	r3, [r3, #12]
  4e:	b29b      	uxth	r3, r3
  50:	461a      	mov	r2, r3
  52:	68fb      	ldr	r3, [r7, #12]
  54:	ea03 0302 	and.w	r3, r3, r2
  58:	60fb      	str	r3, [r7, #12]
  5a:	e013      	b.n	84 <RCC_GetClocksFreq+0x84>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:979
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
  5c:	693b      	ldr	r3, [r7, #16]
  5e:	2b02      	cmp	r3, #2
  60:	d108      	bne.n	74 <RCC_GetClocksFreq+0x74>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:981
  {
    itmask &= USARTx->CR2;
  62:	687b      	ldr	r3, [r7, #4]
  64:	8a1b      	ldrh	r3, [r3, #16]
  66:	b29b      	uxth	r3, r3
  68:	461a      	mov	r2, r3
  6a:	68fb      	ldr	r3, [r7, #12]
  6c:	ea03 0302 	and.w	r3, r3, r2
  70:	60fb      	str	r3, [r7, #12]
  72:	e007      	b.n	84 <RCC_GetClocksFreq+0x84>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:985
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
  74:	687b      	ldr	r3, [r7, #4]
  76:	8a9b      	ldrh	r3, [r3, #20]
  78:	b29b      	uxth	r3, r3
  7a:	461a      	mov	r2, r3
  7c:	68fb      	ldr	r3, [r7, #12]
  7e:	ea03 0302 	and.w	r3, r3, r2
  82:	60fb      	str	r3, [r7, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:988
  }
  
  bitpos = USART_IT >> 0x08;
  84:	887b      	ldrh	r3, [r7, #2]
  86:	ea4f 2313 	mov.w	r3, r3, lsr #8
  8a:	b29b      	uxth	r3, r3
  8c:	60bb      	str	r3, [r7, #8]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:989
  bitpos = (uint32_t)0x01 << bitpos;
  8e:	68ba      	ldr	r2, [r7, #8]
  90:	f04f 0301 	mov.w	r3, #1	; 0x1
  94:	fa03 f302 	lsl.w	r3, r3, r2
  98:	60bb      	str	r3, [r7, #8]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:990
  bitpos &= USARTx->SR;
  9a:	687b      	ldr	r3, [r7, #4]
  9c:	881b      	ldrh	r3, [r3, #0]
  9e:	b29b      	uxth	r3, r3
  a0:	461a      	mov	r2, r3
  a2:	68bb      	ldr	r3, [r7, #8]
  a4:	ea03 0302 	and.w	r3, r3, r2
  a8:	60bb      	str	r3, [r7, #8]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:991
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
  aa:	68fb      	ldr	r3, [r7, #12]
  ac:	2b00      	cmp	r3, #0
  ae:	d006      	beq.n	be <RCC_GetClocksFreq+0xbe>
  b0:	68bb      	ldr	r3, [r7, #8]
  b2:	2b00      	cmp	r3, #0
  b4:	d003      	beq.n	be <RCC_GetClocksFreq+0xbe>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:993
  {
    bitstatus = SET;
  b6:	f04f 0301 	mov.w	r3, #1	; 0x1
  ba:	75fb      	strb	r3, [r7, #23]
  bc:	e002      	b.n	c4 <RCC_GetClocksFreq+0xc4>
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:997
  }
  else
  {
    bitstatus = RESET;
  be:	f04f 0300 	mov.w	r3, #0	; 0x0
  c2:	75fb      	strb	r3, [r7, #23]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:1000
  }
  
  return bitstatus;  
  c4:	7dfb      	ldrb	r3, [r7, #23]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:1001
}
  c6:	4618      	mov	r0, r3
  c8:	f107 071c 	add.w	r7, r7, #28	; 0x1c
  cc:	46bd      	mov	sp, r7
  ce:	bc80      	pop	{r7}
  d0:	4770      	bx	lr
  d2:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.USART_ClearITPendingBit:

00000000 <USART_ClearITPendingBit>:
USART_ClearITPendingBit():
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:1031
  *   - TXE pending bit is cleared only by a write to the USART_DR register 
  *     (USART_SendData()).
  * @retval None
  */
void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:1032
  uint16_t bitpos = 0x00, itmask = 0x00;
   c:	f04f 0300 	mov.w	r3, #0	; 0x0
  10:	81bb      	strh	r3, [r7, #12]
  12:	f04f 0300 	mov.w	r3, #0	; 0x0
  16:	81fb      	strh	r3, [r7, #14]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:1042
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  bitpos = USART_IT >> 0x08;
  18:	887b      	ldrh	r3, [r7, #2]
  1a:	ea4f 2313 	mov.w	r3, r3, lsr #8
  1e:	81bb      	strh	r3, [r7, #12]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:1043
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
  20:	89ba      	ldrh	r2, [r7, #12]
  22:	f04f 0301 	mov.w	r3, #1	; 0x1
  26:	fa03 f302 	lsl.w	r3, r3, r2
  2a:	81fb      	strh	r3, [r7, #14]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:1044
  USARTx->SR = (uint16_t)~itmask;
  2c:	89fb      	ldrh	r3, [r7, #14]
  2e:	ea6f 0303 	mvn.w	r3, r3
  32:	b29b      	uxth	r3, r3
  34:	687a      	ldr	r2, [r7, #4]
  36:	8013      	strh	r3, [r2, #0]
D:\ST\STM32F1\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_usart.c:1045
}
  38:	f107 0714 	add.w	r7, r7, #20	; 0x14
  3c:	46bd      	mov	sp, r7
  3e:	bc80      	pop	{r7}
  40:	4770      	bx	lr
  42:	46c0      	nop			(mov r8, r8)
